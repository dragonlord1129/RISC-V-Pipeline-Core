$date
	Mon Jan 13 13:30:13 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module pipeline_top_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module dut $end
$var wire 1 # MemWriteM $end
$var wire 5 $ RDW [4:0] $end
$var wire 5 % RD_W_W [4:0] $end
$var wire 1 & RegWriteW $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 ' WriteDataM [31:0] $end
$var wire 32 ( ResultW [31:0] $end
$var wire 2 ) ResultSrcE [1:0] $end
$var wire 1 * RegWriteM $end
$var wire 1 + RegWriteE $end
$var wire 32 , ReadDataW [31:0] $end
$var wire 5 - RS2_E [4:0] $end
$var wire 5 . RS1_E [4:0] $end
$var wire 5 / RD_M [4:0] $end
$var wire 5 0 RD_E [4:0] $end
$var wire 32 1 RD2_E [31:0] $end
$var wire 32 2 RD1_E [31:0] $end
$var wire 32 3 PCTargetE [31:0] $end
$var wire 1 4 PCSrcE $end
$var wire 32 5 PCPlus4D [31:0] $end
$var wire 32 6 PCE [31:0] $end
$var wire 32 7 PCD [31:0] $end
$var wire 1 8 MemWriteE $end
$var wire 32 9 InstrD [31:0] $end
$var wire 32 : Imm_Ext_E [31:0] $end
$var wire 2 ; ForwardBE [1:0] $end
$var wire 2 < ForwardAE [1:0] $end
$var wire 1 = BranchE $end
$var wire 1 > ALUSrcE $end
$var wire 32 ? ALUResultM [31:0] $end
$var wire 3 @ ALUControlE [2:0] $end
$scope module decode $end
$var wire 3 A ALUControlE [2:0] $end
$var wire 1 > ALUSrcE $end
$var wire 1 = BranchE $end
$var wire 32 B Imm_Ext_E [31:0] $end
$var wire 1 C JumpE $end
$var wire 1 8 MemWriteE $end
$var wire 32 D PCE [31:0] $end
$var wire 32 E PCPlus4E [31:0] $end
$var wire 32 F RD1_E [31:0] $end
$var wire 32 G RD2_E [31:0] $end
$var wire 5 H RDW [4:0] $end
$var wire 5 I RD_E [4:0] $end
$var wire 5 J RS1_E [4:0] $end
$var wire 5 K RS2_E [4:0] $end
$var wire 1 + RegWriteE $end
$var wire 1 & RegWriteW $end
$var wire 2 L ResultSrcE [1:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 M readData2_D [31:0] $end
$var wire 32 N readData1_D [31:0] $end
$var wire 32 O ResultW [31:0] $end
$var wire 2 P ResultSrcD [1:0] $end
$var wire 1 Q RegWriteD $end
$var wire 32 R PCPlus4D [31:0] $end
$var wire 32 S PCD [31:0] $end
$var wire 1 T MemWriteD $end
$var wire 1 U JumpD $end
$var wire 32 V InstrD [31:0] $end
$var wire 32 W Imm_Ext_D [31:0] $end
$var wire 2 X ImmSrcD [1:0] $end
$var wire 1 Y BranchD $end
$var wire 1 Z ALUSrcD $end
$var wire 3 [ ALUControlD [2:0] $end
$var reg 3 \ ALUControlD_R [2:0] $end
$var reg 1 > ALUSrcD_R $end
$var reg 1 = BranchD_R $end
$var reg 32 ] Imm_Ext_D_R [31:0] $end
$var reg 1 ^ JumpD_R $end
$var reg 1 _ MemWriteD_R $end
$var reg 32 ` PCD_R [31:0] $end
$var reg 32 a PCPlus4D_R [31:0] $end
$var reg 32 b RD1_D_R [31:0] $end
$var reg 32 c RD2_D_R [31:0] $end
$var reg 5 d RD_D_R [4:0] $end
$var reg 5 e RS1_D_R [4:0] $end
$var reg 5 f RS2_D_R [4:0] $end
$var reg 1 g RegWriteD_R $end
$var reg 2 h ResultSrcD_R [1:0] $end
$scope module control_unit $end
$var wire 3 i funct3 [2:0] $end
$var wire 7 j funct7 [6:0] $end
$var wire 7 k opcode [6:0] $end
$var wire 2 l ResultSrc [1:0] $end
$var wire 1 Q RegWrite $end
$var wire 1 T MemWrite $end
$var wire 1 U Jump $end
$var wire 2 m ImmSrc [1:0] $end
$var wire 1 Y Branch $end
$var wire 1 Z ALUSrc $end
$var wire 2 n ALUOp [1:0] $end
$var wire 3 o ALUControl [2:0] $end
$scope module alu_decoder $end
$var wire 3 p funct3 [2:0] $end
$var wire 7 q funct7 [6:0] $end
$var wire 7 r opcode [6:0] $end
$var wire 2 s concatenation [1:0] $end
$var wire 2 t ALUOp [1:0] $end
$var wire 3 u ALUControl [2:0] $end
$upscope $end
$scope module main_decoder $end
$var wire 7 v opcode [6:0] $end
$var wire 2 w ResultSrc [1:0] $end
$var wire 1 Q RegWrite $end
$var wire 1 T MemWrite $end
$var wire 1 U Jump $end
$var wire 2 x ImmSrc [1:0] $end
$var wire 1 Y Branch $end
$var wire 1 Z ALUSrc $end
$var wire 2 y ALUOp [1:0] $end
$upscope $end
$upscope $end
$scope module registerFile $end
$var wire 1 ! clk $end
$var wire 5 z rd [4:0] $end
$var wire 5 { rs1 [4:0] $end
$var wire 5 | rs2 [4:0] $end
$var wire 1 " rst $end
$var wire 1 & writeEnable $end
$var wire 32 } writeData [31:0] $end
$var wire 32 ~ readData2 [31:0] $end
$var wire 32 !" readData1 [31:0] $end
$upscope $end
$scope module sign_extend $end
$var wire 2 "" ImmSrc [1:0] $end
$var wire 32 #" In [31:0] $end
$var wire 32 $" Imm_Ext [31:0] $end
$upscope $end
$upscope $end
$scope module execute $end
$var wire 3 %" ALUControlE [2:0] $end
$var wire 32 &" ALUResultM [31:0] $end
$var wire 32 '" ALUResultM_E [31:0] $end
$var wire 1 > ALUSrcE $end
$var wire 1 = BranchE $end
$var wire 32 (" Imm_Ext_E [31:0] $end
$var wire 1 )" JumpE $end
$var wire 1 8 MemWriteE $end
$var wire 1 *" MemWriteM $end
$var wire 32 +" PCE [31:0] $end
$var wire 32 ," PCPlus4E [31:0] $end
$var wire 32 -" PCPlus4M [31:0] $end
$var wire 1 4 PCSrcE $end
$var wire 32 ." RD1_E [31:0] $end
$var wire 32 /" RD2_E [31:0] $end
$var wire 5 0" RD_E [4:0] $end
$var wire 5 1" RD_M [4:0] $end
$var wire 5 2" RS1_E [4:0] $end
$var wire 5 3" RS1_E_H [4:0] $end
$var wire 5 4" RS2_E [4:0] $end
$var wire 5 5" RS2_E_H [4:0] $end
$var wire 1 + RegWriteE $end
$var wire 1 * RegWriteM $end
$var wire 2 6" ResultSrcE [1:0] $end
$var wire 2 7" ResultSrcM [1:0] $end
$var wire 32 8" ResultW [31:0] $end
$var wire 32 9" WriteDataE [31:0] $end
$var wire 32 :" WriteDataM [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 ;" ZeroE $end
$var wire 32 <" SrcBE_M [31:0] $end
$var wire 32 =" SrcBE [31:0] $end
$var wire 32 >" SrcAE [31:0] $end
$var wire 32 ?" ResultE [31:0] $end
$var wire 32 @" PCTargetE [31:0] $end
$var wire 2 A" ForwardBE [1:0] $end
$var wire 2 B" ForwardAE [1:0] $end
$var reg 32 C" ALUResultE_R [31:0] $end
$var reg 1 D" MemWriteE_R $end
$var reg 32 E" PCPlus4E_R [31:0] $end
$var reg 5 F" RD_E_R [4:0] $end
$var reg 1 * RegWriteE_R $end
$var reg 2 G" ResultSrcE_R [1:0] $end
$var reg 32 H" WriteDataE_R [31:0] $end
$scope module SrcAEMux $end
$var wire 32 I" a [31:0] $end
$var wire 32 J" b [31:0] $end
$var wire 32 K" c [31:0] $end
$var wire 2 L" s [1:0] $end
$var wire 32 M" d [31:0] $end
$upscope $end
$scope module SrcBEMux $end
$var wire 32 N" a [31:0] $end
$var wire 32 O" b [31:0] $end
$var wire 32 P" c [31:0] $end
$var wire 2 Q" s [1:0] $end
$var wire 32 R" d [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 S" A [31:0] $end
$var wire 3 T" ALUControl [2:0] $end
$var wire 32 U" A_and_B [31:0] $end
$var wire 32 V" A_or_B [31:0] $end
$var wire 32 W" A_xor_B [31:0] $end
$var wire 1 X" carry $end
$var wire 32 Y" not_B [31:0] $end
$var wire 1 Z" overflow $end
$var wire 32 [" result [31:0] $end
$var wire 1 ;" zero $end
$var wire 32 \" sum [31:0] $end
$var wire 32 ]" slt [31:0] $end
$var wire 1 ^" negative $end
$var wire 32 _" mux_2 [31:0] $end
$var wire 32 `" mux_1 [31:0] $end
$var wire 1 a" cout $end
$var wire 32 b" B [31:0] $end
$upscope $end
$scope module mux_1 $end
$var wire 32 c" a [31:0] $end
$var wire 32 d" b [31:0] $end
$var wire 1 > s $end
$var wire 32 e" c [31:0] $end
$upscope $end
$scope module pc_adder $end
$var wire 32 f" a [31:0] $end
$var wire 32 g" b [31:0] $end
$var wire 32 h" c [31:0] $end
$upscope $end
$upscope $end
$scope module fetch $end
$var wire 1 4 PCSrcE $end
$var wire 32 i" PCTargetE [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 j" PC_F [31:0] $end
$var wire 32 k" PCPlus4F [31:0] $end
$var wire 32 l" PCPlus4D [31:0] $end
$var wire 32 m" PCF [31:0] $end
$var wire 32 n" PCD [31:0] $end
$var wire 32 o" InstrF [31:0] $end
$var wire 32 p" InstrD [31:0] $end
$var reg 32 q" InstrF_reg [31:0] $end
$var reg 32 r" PCF_reg [31:0] $end
$var reg 32 s" PCPlus4F_reg [31:0] $end
$scope module Instruction_Memory $end
$var wire 1 " rst $end
$var wire 32 t" RD [31:0] $end
$var wire 32 u" A [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 v" PC_next [31:0] $end
$var reg 32 w" PC [31:0] $end
$upscope $end
$scope module PC_Adder $end
$var wire 32 x" a [31:0] $end
$var wire 32 y" b [31:0] $end
$var wire 32 z" c [31:0] $end
$upscope $end
$scope module PC_Mux $end
$var wire 32 {" a [31:0] $end
$var wire 32 |" b [31:0] $end
$var wire 1 4 s $end
$var wire 32 }" c [31:0] $end
$upscope $end
$upscope $end
$scope module hazard $end
$var wire 5 ~" RD_M [4:0] $end
$var wire 5 !# RD_W_W [4:0] $end
$var wire 5 "# RS1_E [4:0] $end
$var wire 5 ## RS2_E [4:0] $end
$var wire 1 * RegWriteM $end
$var wire 1 $# RegWriteW_W $end
$var wire 1 " rst $end
$var wire 2 %# ForwardBE [1:0] $end
$var wire 2 &# ForwardAE [1:0] $end
$upscope $end
$scope module memory $end
$var wire 32 '# ALUResultM [31:0] $end
$var wire 32 (# ALUResultW [31:0] $end
$var wire 1 # MemWriteM $end
$var wire 32 )# PCPlus4M [31:0] $end
$var wire 32 *# PCPlus4W [31:0] $end
$var wire 5 +# RD_M [4:0] $end
$var wire 5 ,# RD_W [4:0] $end
$var wire 32 -# ReadDataW [31:0] $end
$var wire 1 * RegWriteM $end
$var wire 1 .# RegWriteW $end
$var wire 2 /# ResultSrcM [1:0] $end
$var wire 2 0# ResultSrcW [1:0] $end
$var wire 32 1# WriteDataM [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 2# ReadDataM_W [31:0] $end
$var reg 32 3# ALUResultM_R [31:0] $end
$var reg 32 4# PCPlus4M_R [31:0] $end
$var reg 5 5# RD_M_R [4:0] $end
$var reg 32 6# ReadDataM_R [31:0] $end
$var reg 1 7# RegWriteM_R $end
$var reg 2 8# ResultSrcM_R [1:0] $end
$scope module data_memory $end
$var wire 32 9# A [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 :# writeData [31:0] $end
$var wire 1 # writeEnable $end
$var wire 32 ;# RD [31:0] $end
$upscope $end
$upscope $end
$scope module writeback $end
$var wire 32 <# ALUResultW [31:0] $end
$var wire 32 =# PCPlus4W [31:0] $end
$var wire 5 ># RD_W [4:0] $end
$var wire 5 ?# RD_W_W [4:0] $end
$var wire 32 @# ReadDataW [31:0] $end
$var wire 1 & RegWriteW $end
$var wire 1 A# RegWriteW_W $end
$var wire 2 B# ResultSrcW [1:0] $end
$var wire 32 C# ResultW [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 D# ResultW_X [31:0] $end
$var reg 5 E# RD_W_R [4:0] $end
$var reg 1 F# RegWriteW_R $end
$var reg 32 G# ResultW_R [31:0] $end
$scope module mux_3_by_1 $end
$var wire 32 H# a [31:0] $end
$var wire 32 I# b [31:0] $end
$var wire 32 J# c [31:0] $end
$var wire 2 K# s [1:0] $end
$var wire 32 L# d [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx L#
bz K#
bz J#
b0 I#
bz H#
b0 G#
0F#
b0 E#
bx D#
b0 C#
bz B#
0A#
b0 @#
b0 ?#
bz >#
bz =#
bz <#
b0 ;#
b0 :#
b0 9#
b0 8#
07#
b0 6#
b0 5#
b0 4#
b0 3#
b0 2#
b0 1#
b0 0#
bz /#
0.#
b0 -#
b0 ,#
b0 +#
b0 *#
bz )#
b0 (#
b0 '#
b0 &#
b0 %#
z$#
b0 ##
b0 "#
bz !#
b0 ~"
bx }"
bx |"
b100 {"
b100 z"
b100 y"
b0 x"
b0 w"
bx v"
b0 u"
b0 t"
b0 s"
b0 r"
b0 q"
b0 p"
b0 o"
b0 n"
b0 m"
b0 l"
b100 k"
bx j"
bx i"
bx h"
b0 g"
bz f"
b0 e"
b0 d"
b0 c"
b0 b"
0a"
b0 `"
b0 _"
0^"
b0 ]"
b0 \"
b0 ["
0Z"
b11111111111111111111111111111111 Y"
0X"
b0 W"
b0 V"
b0 U"
b0 T"
b0 S"
b0 R"
b0 Q"
bz P"
bz O"
b0 N"
b0 M"
b0 L"
bz K"
bz J"
b0 I"
b0 H"
b0 G"
b0 F"
b0 E"
0D"
b0 C"
b0 B"
b0 A"
bx @"
b0 ?"
b0 >"
b0 ="
b0 <"
1;"
b0 :"
b0 9"
bz 8"
b0 7"
bz 6"
b0 5"
b0 4"
b0 3"
b0 2"
b0 1"
b0 0"
b0 /"
b0 ."
b0 -"
bz ,"
bz +"
0*"
z)"
b0 ("
bz '"
b0 &"
b0 %"
b0 $"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b0 |
b0 {
bz z
b0 y
b0 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
b0 q
b0 p
b0 o
b0 n
b0 m
b0 l
b0 k
b0 j
b0 i
b0 h
0g
b0 f
b0 e
b0 d
b0 c
b0 b
b0 a
b0 `
0_
0^
b0 ]
b0 \
b0 [
0Z
0Y
b0 X
b0 W
b0 V
0U
0T
b0 S
b0 R
0Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
bz H
b0 G
b0 F
b0 E
b0 D
0C
b0 B
b0 A
b0 @
b0 ?
0>
0=
b0 <
b0 ;
b0 :
b0 9
08
b0 7
b0 6
b0 5
x4
bx 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
b0 ,
0+
0*
b0 )
b0 (
b0 '
z&
bz %
bz $
z#
0"
1!
$end
#50
0!
#100
1!
#150
0!
#200
xZ"
x;"
x^"
b0x ]"
bx ?"
bx ["
bx _"
xX"
bx `"
bx Y"
bx U"
bx V"
bx W"
bx \"
xa"
bx ="
bx b"
bx e"
bx >"
bx M"
bx S"
bx <"
bx R"
bx c"
b10100000000001010010011 o"
b10100000000001010010011 t"
b0x <
b0x B"
b0x L"
b0x &#
b0x ;
b0x A"
b0x Q"
b0x %#
bx 2#
bx ;#
1"
1!
#250
0!
#300
b101 W
b101 $"
bx o"
bx t"
b101 |
b10011 k
b10011 r
b10011 v
b100 5
b100 R
b100 l"
b10100000000001010010011 9
b10100000000001010010011 V
b10100000000001010010011 #"
b10100000000001010010011 p"
bx k"
bx z"
bx {"
bx m"
bx u"
bx w"
bx x"
b100 s"
b10100000000001010010011 q"
bz -"
bz E"
bz 7"
bz G"
bx '
bx :"
bx 1#
bx :#
bx H"
bx ?
bx &"
bx C"
bx '#
bx 9#
bz *#
bz 4#
bx ,
bx -#
bx 6#
bx @#
bx I#
bz 0#
bz 8#
zA#
zF#
bz ?#
bz E#
bx (
bx O
bx }
bx C#
bx G#
1!
#350
0!
#400
bx [
bx o
bx u
xQ
xZ
xU
bx n
bx t
bx y
bx W
bx $"
bx s
xT
xY
bx X
bx m
bx x
bx ""
bx P
bx l
bx w
bx |
bx {
bx i
bx p
bx j
bx q
bx k
bx r
bx v
bx 5
bx R
bx l"
bx 7
bx S
bx n"
bx 9
bx V
bx #"
bx p"
bx (#
bx 3#
b101 5"
b101 -
b101 K
b101 f
b101 4"
b101 ##
b100 E
b100 a
b101 0
b101 I
b101 0"
b101 d
b101 :
b101 B
b101 ]
b101 ("
b101 d"
b101 g"
bx s"
bx r"
bx q"
1!
#450
0!
#500
bx 5"
bx -
bx K
bx f
bx 4"
bx ##
bx 3"
bx .
bx J
bx e
bx 2"
bx "#
bx E
bx a
bx 6
bx D
bx `
bx 0
bx I
bx 0"
bx d
bx :
bx B
bx ]
bx ("
bx d"
bx g"
bx @
bx A
bx \
bx %"
bx T"
xC
x^
x=
bx )
bx L
bx h
x8
x_
x>
x+
xg
b101 /
b101 1"
b101 F"
b101 ~"
b101 +#
1!
#550
0!
#600
bx <
bx B"
bx L"
bx &#
bx ;
bx A"
bx Q"
bx %#
b101 ,#
b101 5#
bx /
bx 1"
bx F"
bx ~"
bx +#
x*"
xD"
x*
1!
#650
0!
#700
bx ,#
bx 5#
x.#
x7#
1!
#750
0!
#800
1!
#850
0!
#900
1!
#950
0!
#1000
1!
#1050
0!
#1100
1!
#1150
0!
#1200
1!
